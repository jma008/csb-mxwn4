{"version":3,"sources":["App.js","index.js"],"names":["CounterApp","useImmer","count","appState","updateAppState","onClick","draft","baseURL","TaskForm","taskInput","taskAction","onSubmit","event","preventDefault","value","ref","r","type","TodoFilter","filterType","setFilterType","map","item","index","TasksApp","props","tasks","initial","updateState","useEffect","asyncDataFromServer","setTasks","a","fetch","method","response","ok","json","result","console","log","async_create","title","data","requestOption","headers","body","JSON","stringify","error","async_troggle","id","targetURL","updated","i","length","completed","style","listStyleType","filtered","forEach","task","push","filteredTasks","toggleTask","App","className","rootElement","document","getElementById","ReactDOM","render"],"mappings":"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","file":"static/js/main.9a115e17.chunk.js","sourcesContent":["import \"./styles.css\";\nimport { useImmer } from \"use-immer\";\nimport Task from \"./Task\";\nimport { useEffect } from \"react\";\n\nconst CounterApp = () => {\n  // useImmer is a function that takes the initial state of the app and returns\n  // two items: appState and updateAppState\n  // appState holds the current state of the app (a simple object with a count attribute)\n  // updateAppState is a function that takes a user-supplied update function as its argument.\n  const [appState, updateAppState] = useImmer({\n    count: 0\n    // {count: 0}\n  });\n  // appState : object, the state of the component\n  // updateAppState : function, used to set the new state of this component\n  const incrementCounter = () => {\n    // increment the counter\n    if (appState.count < 10) {\n      // draft : the state of this component\n      // start from 0\n      // draft {count:0}\n      updateAppState((draft) => {\n        draft.count++;\n        // draft.count++ gives\n        // {count: 1}\n      });\n    }\n  };\n\n  const decrementCounter = () => {\n    if (appState.count > 0) {\n      updateAppState((draft) => {\n        draft.count--;\n      });\n    }\n  };\n\n  const resetCounter = () => {\n    updateAppState({ count: 0 });\n  };\n  return (\n    <div>\n      <h2>Counter App</h2>\n      <div> Count: {appState.count} </div>\n      <button onClick={incrementCounter}>Increment</button>\n      <button onClick={decrementCounter}>Decrement</button>\n      <button onClick={resetCounter}> Reset </button>\n    </div>\n  );\n};\n\nconst baseURL = \"http://127.0.0.1:5000\";\n\nconst TaskForm = ({ taskAction }) => {\n  // variable to hold a reference to the input\n  let taskInput;\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    taskAction(taskInput.value);\n    taskInput.value = \"\";\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>\n        <input ref={(r) => (taskInput = r)} type=\"text\" />\n      </label>\n      <input type=\"submit\" value=\"Create Task\" />\n    </form>\n  );\n};\n\nconst TodoFilter = ({ filterType, setFilterType }) => (\n  <span>\n    <b>Filter Todos</b>:\n    {[\"all\", \"completed\", \"active\"].map((item, index) => (\n      // buttons for filters\n      <button\n        key={index}\n        onClick={() => {\n          setFilterType(item);\n        }}\n      >\n        {item}\n      </button>\n    ))}\n  </span>\n);\n\nconst TasksApp = (props) => {\n  const [appState, updateState] = useImmer({\n    filterType: \"all\",\n    tasks: [],\n    initial: false\n  });\n  // By adding the ,[] as second parameter\n  // useEffect will only be executed when component mounted\n  useEffect(() => {\n    asyncDataFromServer();\n  }, []);\n\n  const setTasks = (tasks) => {\n    updateState({ ...appState, tasks: tasks });\n  };\n\n  const fetchDataFromServer = () => {\n    fetch(baseURL + \"/tasks\", { method: \"GET\" })\n      .then((response) => {\n        if (response.ok) return response.json();\n        else throw new Error(\"Bad response status\");\n      })\n      .catch((error) => console.error(\"Error: \", error))\n      .then((data) => {\n        console.log(data);\n        setTasks(data.tasks);\n      });\n  };\n\n  const asyncDataFromServer = async () => {\n    // async/await call\n    const response = await fetch(baseURL + \"/tasks\", { method: \"GET\" });\n    let status = await response.ok;\n    if (!status) {\n      return;\n    }\n    try {\n      let result = await response.json();\n      setTasks(result.tasks);\n    } catch (error) {\n      console.log(error);\n    }\n  };\n\n  const createTask = (title) => {\n    // newTasks, array, a copy of the appState's tasks\n    const data = {\n      title: title\n    };\n    const requestOption = {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(data)\n    };\n    fetch(baseURL + \"/tasks\", requestOption)\n      .then((response) => {\n        if (response.ok) return response.json();\n        else throw new Error(\"Bad response status\");\n      })\n      .catch((error) => console.error(\"Error: \", error))\n      .then((data) => {\n        fetchDataFromServer();\n      });\n  };\n\n  const toggleTask = (id) => {\n    let targetURL = baseURL + \"/tasks/\" + id;\n    // your code here\n    let updated = null;\n    for (let i = 0; i < appState.tasks.length; i++) {\n      if (appState.tasks[i].id === id) {\n        updated = appState.tasks[i];\n      }\n    }\n    if (!updated) {\n      return;\n    }\n    updated.completed = !updated.completed;\n    const data = {\n      id: updated.id,\n      completed: updated.completed\n    };\n    const requestOption = {\n      method: \"PUT\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(data)\n    };\n    fetch(targetURL, requestOption)\n      .then((response) => {\n        if (response.ok) return response.json();\n        else throw new Error(\"Bad response status\");\n      })\n      .catch((error) => console.error(\"Error: \", error))\n      .then((data) => {\n        fetchDataFromServer();\n      });\n  };\n\n  const async_create = async (title) => {\n    const data = {\n      title: title\n    };\n    const requestOption = {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(data)\n    };\n    // async/await call\n    let response = await fetch(baseURL + \"/tasks\", requestOption);\n    let status = await response.ok;\n    if (status) {\n      try {\n        asyncDataFromServer();\n      } catch (error) {\n        console.log(error);\n      }\n    }\n  };\n\n  const async_troggle = async (id) => {\n    let targetURL = baseURL + \"/tasks/\" + id;\n    // your code here\n    let updated = null;\n    for (let i = 0; i < appState.tasks.length; i++) {\n      if (appState.tasks[i].id === id) {\n        updated = appState.tasks[i];\n      }\n    }\n    if (!updated) {\n      return;\n    }\n    updated.completed = !updated.completed;\n    const data = {\n      id: updated.id,\n      completed: updated.completed\n    };\n    const requestOption = {\n      method: \"PUT\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(data)\n    };\n    // async/await call\n    let response = await fetch(targetURL, requestOption);\n    let status = await response.ok;\n    if (status) {\n      try {\n        asyncDataFromServer();\n      } catch (error) {\n        console.log(error);\n      }\n    }\n  };\n\n  const filteredTasks = () => {\n    // your code here\n    let filtered = [];\n    appState.tasks.forEach((task) => {\n      if (appState.filterType === \"all\") {\n        filtered.push(task);\n      } else if (appState.filterType === \"completed\") {\n        if (task.completed) {\n          filtered.push(task);\n        }\n      } else {\n        if (!task.completed) {\n          filtered.push(task);\n        }\n      }\n    });\n    return filtered;\n  };\n\n  const setFilterType = (filterType) => {\n    // your code here\n    updateState({ ...appState, filterType: filterType });\n  };\n\n  // uncomment out JSX blocks as you solve each problem\n  // to uncomment, remove the enclosing '{/*' and '*/}'\n  return (\n    <div>\n      <TaskForm taskAction={async_create} />\n      <h3> Tasks </h3>\n\n      <TodoFilter\n        filterType={appState.filterType}\n        setFilterType={setFilterType}\n      />\n      <ul style={{ listStyleType: \"none\" }}>\n        {filteredTasks().map((task) => (\n          <Task\n            key={task.id}\n            title={task.title}\n            completed={task.completed}\n            toggleTask={() => async_troggle(task.id)}\n          />\n        ))}\n      </ul>\n    </div>\n  );\n};\n\nexport default function App() {\n  return (\n    <div className=\"App\">\n      <TasksApp />\n      <CounterApp />\n    </div>\n  );\n}\n","import { StrictMode } from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport App from \"./App\";\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n  rootElement\n);\n"],"sourceRoot":""}